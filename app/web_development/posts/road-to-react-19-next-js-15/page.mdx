%toc%

<article>

# The road to React 19 and Next.js 15

![banner image of a futuristic city with two signs "react" and "next.js"](../../../../public/assets/images/app/web_development/posts/road-to-react-19-next-js-15/banner.png)

This post is based on research I did a while ago when I first heard about Server Components, I wanted to understand what makes them different from what I was using at that time, I have kept track of the React and Next.js releases which are the first few chapters, then I had some discussions with other devs about the need or not to migrate this is why I wrote the ["do I need to migrate all my code today?"](#do-i-need-to-migrate-all-my-code-today) chapter and finally the last chapters are about finding out what the major changes between the Next.js pages directory and app directory are

I will try to keep this document up to date as things evolve continuously, if you find mistakes please use the [issues](https://github.com/chrisweb/chris.lu/issues) on GitHub to report them and if you want to discuss something related to article feel free to open post it in the [dicussions](https://github.com/chrisweb/chris.lu/discussions) on Github

## React 18.x and beyond

React updates recap:

* On december 21 2020, the react team announced in a [blog post on react.org](https://reactjs.org/blog/2020/12/21/data-fetching-with-react-server-components.html) that they had just published the [RFC: React Server Components](https://github.com/reactjs/rfcs/blob/main/text/0188-server-components.md) on github, as well as an experimental demo [video of React Server Components (RSC) on YouTube](https://www.youtube.com/watch?v=TQQPAU21ZUw)
* In march 2022 they released a blog post announcing the release of [React v18.0](https://reactjs.org/blog/2022/03/29/react-v18.html) and in that post they also mentioned that the **Server Components** were still in development and would get released in a future update, they also posted a new guide on React.dev to help developers [migrate to React 18](https://react.dev/blog/2022/03/08/react-18-upgrade-guide), the [React 18 changelog](https://github.com/facebook/react/releases/tag/v18.0.0) lists a lot improvements, the first one is the introduction of **Concurrent React** and some new hooks mostly useful for CSS-in-JS libraries and external data stores to allow them to work well during concurrent rendering, the second big feature was [Suspense](https://react.dev/reference/react/Suspense) another, **Suspense** is a new feature related to concurrent rendering and the one that makes other new features like **Streaming Server Rendering** and **Selective Hydration** even possible (features that would get mostly used by frameworks in upcoming releases)
* In april 2022 react released the first major update [React 18.1](https://github.com/facebook/react/releases/tag/v18.1.0) which was a maintenance version with a lot of fixes, most were for React DOM
* That same year in june 2022 the React team released [React 18.2](https://github.com/facebook/react/releases/tag/v18.2.0) another maintenance release with again lots of improvements for React DOM
* One year after the first release of React 18 in march 2023 we got another update from the React Team in a blog post [What We've Been Working On](https://react.dev/blog/2023/03/22/react-labs-what-we-have-been-working-on-march-2023), one of the new features they mentioned to be working on were Server Actions (which then first appeared in Next.js 14 in october 2023)
* In may 2023 the React team announced the [Canary release channel](https://react.dev/blog/2023/05/03/react-canaries), the canary releases are officially supported, meaning that if any regressions land, they will treat them with a similar urgency to bugs in stable releases, which for you means that you can use canary releases in production, a lot of frameworks like Next.js, Remix, Astro, ... for example uses those canary releases, which is why frameworks now support **Server Components** and **Server Actions** even though there has not been a stable React release that ships those features
* In february 2024 the React team released another [post](https://react.dev/blog/2024/02/15/react-labs-what-we-have-been-working-on-february-2024) in their series called **What We've Been Working On**, one big announcement was that they were preparing the first open source release of the React compiler in the upcoming months, they also announced that they were working on a client only version of **Server Actions** called **Actions**
* In april 2024 the react team released **React 18.3.0** which was identical to React 18.2.0 but included new warnings for APIs that should now be considered deprecated and other changes needed for the transition to React 19.x

> [!MORE]  
> [React (react.dev) blog](https://react.dev/blog)  
> [React releases list and changelogs on GitHub](https://github.com/facebook/react/releases)  

## React 19

* On april 25 2024 the react team released the **first beta** ðŸš€ of **React 19** on [npmjs.com](https://www.npmjs.com/package/react/v/19.0.0-beta-94eed63c49-20240425), they announced the [release of React 19 (beta)](https://react.dev/blog/2024/04/25/react-19) in a blog post that same day, the post contains a recap of the most interesting features that are included in React 19, the new **client Actions** that are the counterpart to Server Actions but the client ones are just called Actions (not Client Actions), the new **use** API, **Server Components** and **Server Actions** that you might already be using as frameworks like Next.js and Remix (to just name those two) has already access to those features via the canary releases, support for document metadata and a lot more that I won't list here as I recommend you check out their [release of React 19 (beta)](https://react.dev/blog/2024/04/25/react-19) blog post for a more complete list and details
* In april 2024 the react team published the first React 19 migration guide which list the upcoming changes in React 19, there is also a valuable [chapter about codemods](https://react.dev/blog/2024/04/25/react-19-upgrade-guide#typescript-changes), codemods are a great help especially when you intend to migrate the types and already have a big codebase
* During [React Conf 2024](https://react.dev/blog/2024/05/22/react-conf-2024-recap) in april 2024 the React team announced the release of the first [React 19 RC](https://react.dev/blog/2024/04/25/react-19) (release candidate), another big announcement was the experimental release of the [React Compiler](https://react.dev/learn/react-compiler)

> [!MORE]  
> [react.dev "React 19 (beta)" post](https://react.dev/blog/2024/04/25/react-19)  
> [react.dev "React 19 migration" guide](https://react.dev/blog/2024/04/25/react-19-upgrade-guide)  
> [react.dev "React 19 RC" post](https://react.dev/blog/2024/04/25/react-19)  
> [react.dev "React Compiler" documentation](https://react.dev/learn/react-compiler)  

## new features in Next.js prior to v13

Since version v10.2.1 Next.js enabled [Incremental type checking](https://www.typescriptlang.org/tsconfig#incremental), making builds much faster and for example in version v13.2.0 they added **Statically Typed Links (Routes)**, all these new Typescript features are listed in the [Next.js "TypeScript" documentation](https://nextjs.org/docs/app/building-your-application/configuring/typescript), which I recommend checking out one in a while as the Next.js team adds new and interesting features over time

Starting with version 12 Next.js typescript compilation is now much faster thx to the Next.js ["SWC"](https://swc.rs/) compiler written in Rust, for a bit of history and more in depth information check out their [Next.js "SWC compiler" documentation](https://nextjs.org/docs/advanced-features/compiler), also in [version 12 Next.js](https://nextjs.org/blog/next-12#react-server-components) started experimenting with React Server Components and they added the feature as alpha version (but no app directory yet)

> [!MORE]  
> [Next.js "TypeScript" documentation](https://nextjs.org/docs/app/building-your-application/configuring/typescript)  
> [Next.js "SWC compiler" documentation](https://nextjs.org/docs/advanced-features/compiler)  

## Next.js v13

In may 2022 the next.js team released the [Layouts RFC](https://nextjs.org/blog/layouts-rfc) and sketched out their ideas for server components, but also improved data fetching and things like nested layouts, alongside the RFC posted on their blog they opened a [github discussion regarding the layouts RFC](https://github.com/vercel/next.js/discussions/37136)

Next.js 13 releases:

* In october 2022 the next.js team released [Next.js 13](https://nextjs.org/blog/next-13) which included the first beta version of the new `app` directory (**App Router**), with the new app router and thanks to React 18 Next.js now also comes with a new feature called **React Server Components**, in this release we also got the first alpha of [Turbopack](https://turbo.build/pack) a new bundler written in Rust that someday will replace webpack in Next.js projects, next/image got a complete overhaul in that version and the previous version got renamed to [next/legacy/image](https://nextjs.org/docs/pages/api-reference/components/image-legacy) (which means that if you migrate your code to a newer Next.js version you can use the legacy image component but for new projects it is highly recommended that you use the new version of next/image), another new component they introduced in that version is the next/font (in beta), next/font is similar to next/image but for fonts, meaning it will optimize your font usage by making them soft hosted (compared to fetching them from a remote CDN) which reduces layout shifts when using fonts that are not installed on the users device, yet another new component they updated is next/link which now does not require your to add `<a>{:html}` element as child
* Two months later in december 2022 [Next.js 13.1](https://nextjs.org/blog/next-13-1) which brought a lot of improvements for the new app directory but also for middlewares, Turbopack as well as [SWC](https://swc.rs/) a tool written in Rust to replace babel
* In february 2023 we got [Next.js 13.2](https://nextjs.org/blog/next-13-2) which brought the new [Metadata Files API](https://nextjs.org/docs/app/api-reference/file-conventions/metadata) for built SEO support and [MDX](https://mdxjs.com/) for Server Components ([MDX app directory support](https://nextjs.org/docs/app/building-your-application/configuring/mdx))
* In april 2023 we got [Next.js 13.3](https://nextjs.org/blog/next-13-3) which brought improvements for SEO tools like the [Metadata Files API](https://nextjs.org/docs/app/api-reference/file-conventions/metadata) and automatically generated OpenGraph Images, as well as a new routes feature that looks very promising called [Parallel Routes](https://nextjs.org/docs/app/building-your-application/routing/parallel-routes) which allows you to render the content of two (or more) routes in a single layout, which is probably going to be very helpfull when building things like dashboards or complex admin panels
* In may 203 we got [Next.js 13.4](https://nextjs.org/blog/next-13-4) which is the first version of next.js 13 in which the **App Router** is considered being stable (meaning it has left beta) another big new feature in Next.js 13.4 was the introduction of **Server Actions** in alpha, the goal is the new [Server Actions](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations) is to allow devs to mutate data without the use of an API and also make it possible to create progressively enhanced forms (forms that work even if javascript has not been loaded yet), Turbopack got updated too and is now considered beta (previously alpha)
* The last 13.x version the Next.js team released was [Next.js 13.5](https://nextjs.org/blog/next-13-5) in september 2023, this version had almost no new features but a lot of performance optimisations as well as bug fixes

## Next.js 14

* In october 2023 (one year after the release of Next.js 13) the Next.js team released the first [Next.js 14](https://nextjs.org/blog/next-14) version, in this version the **Server Actions** feature (that they introduced in version 13.4 as alpha) is now considered being stable (meaning you can safely use it in production now), this version also another interesting new feature called **Partial Prerendering (PPR)** (currently in preview / experimental), [Partial Prerendering](https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering) will allow us to mix static and dynamic content in a route (page), as of now if you use the noStore cache option or the cookies() function then your entire route will opt out of static rendering (and become dynamic), however with partial rendering you will be able to include dynamic components into a page and if you wrap them into a suspense boundary then the component will be dynamic but the rest will still be static, **PPR** is only available for testing and should not be used for production, if you want to try it out **you MUST use next@canary** and enable it manually in the Next.js configuration
* In january 2024 the Next.js team released [Next.js 14.1](https://nextjs.org/blog/next-14-1) providing a stable version of custom cache handlers and there is now a configuration option to instruct Next.js to log cache **HITs** and **SKIPs** when running in development mode, this version also came with many improvements for fast refresh, error messages, parallel & intercepted routes and Turbo
* In april 2024 the Next.js team released [Next.js 14.2](https://nextjs.org/blog/next-14-2) added a new experimental option to called [staleTimes](https://nextjs.org/docs/app/api-reference/next-config-js/staleTimes) to let developers to set custom revalidation times for the [Router Cache](https://nextjs.org/docs/app/building-your-application/caching#router-cache), this version also came with some changes intended to improve Tree-shaking and builds should now use less memory

> [!MORE]  
> [Next.js 13 to 14 upgrade guide](https://rc.nextjs.org/docs/app/building-your-application/upgrading/version-14)  
> [Next.js "partiel prerendering" documentation](https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering)  
> [Turbopack "are we turbo yet" (percentage of tests Turbopack passes)](https://areweturboyet.com/)  

## Next.js 15

* In may 2024 the Next.js team released the first [Next.js 15 RC](https://nextjs.org/blog/next-15-rc) (release candidate) which included a big change for [caching](https://nextjs.org/blog/next-15-rc#caching-updates), the Next.js team decided that from now on all caching would be opt-in instead of being enabled by default, the problem with with caching enabled by default was that in development even though caching was enabled the content (fetch requests, routes, client navigation) would not get cached, caching would only happen during the build process, this made it hard to detect problems linked to caching before publishing the app, another change is that Next.js now includes React 19 RC (see my [React 19 chapter](#react-19) for details about what's new in React 19), **Partial Prerendering (PPR)** which previously was only available when using the release candidates is not included in this release and there is a new **experimental_ppr** feature that allows you to enable PPR only on certain pages, included is also a new feature called **next/after** which is an experimental API to execute code after your content got streamed to the user, a new layout for **create-next-app** as well as new configuration options to opt out of bundling for certain packages

> [!MORE]  
> [Next.js 14 to 15 upgrade guide](https://rc.nextjs.org/docs/app/building-your-application/upgrading/version-15)  

## do I need to migrate all my code today?

Do I need to move all my code from pages to the app directory and do I need to use Server Components and / or Server Actions?

TLDR: NO!

The app directory and server side React are all features you can opt in when ready, but nobody forces you to use them. The pages directory still exists in Next.js 13 and 14 and React is still has all the client components features it had before the additions of Server Components and Server Actions.

This means you can still start a new project today and use the pages directory (I however don't recommend it) and if you have an existing codebase you don't need to migrate everything at once from pages to the app directory, you can do it bit by bit. If however if you start a new project from scratch then I recommend that you consider using the app directory as well as Server Components and eventually Server Actions, because those technologies are more future proof and also include a lot of great features the pages router or React client side only projects do not have

If you are already using a previous version of Next.js and are migrating to one of the latest versions then I highly recommend you first check out the [Next.js "codemods" documentation](https://nextjs.org/docs/pages/building-your-application/upgrading/codemods) as these might save you a lot of time, another good read is the [Next.js app router migration guide](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration)

> [!MORE]  
> [Next.js "App Router Incremental Adoption" documentation](https://nextjs.org/docs/app/building-your-application/upgrading/app-router-migration)  
> [Next.js "codemods" documentation](https://nextjs.org/docs/pages/building-your-application/upgrading/codemods)  

## pages VS app router

This is a introduction to differences between Next.js app and pages router

### routing in pages VS app

Not so long ago all Next.js only had the **pages** directory, since the first release of Next.js 13, Next.js now has two directories to chose from the **pages** and **app** directories, which correspond to the [pages router](https://nextjs.org/docs/pages/building-your-application/routing) and the [app router](https://nextjs.org/docs/app/building-your-application/routing), both are file based routers but how files are being used differs:

* the **pages** router (/pages directory) a page file `/pages/foo.tsx` will be available at the URL `example.com/foo` and `/pages/bar/baz.tsx` will be reachable at `example.com/bar/baz`
* with the **app** it is different, the page file name is always the same, every page is a `page.tsx`, so only the directory structure defines the route segments, so the URL `example.com/foo` would be a file in `/app/foo/page.tsx` and `example.com/bar/baz` a file in `/app/bar/baz/page.tsx`

When using **app router** (`/app` directory) each URL segment corresponds to a directory, which means we can put more than just pages in a directory, one of those [routing files](https://nextjs.org/docs/getting-started/project-structure#routing-files) for example is a `layout.tsx` file, which allows us to build nested layouts, or the `loading.tsx` file to add a loader that gets displayed while the content of the page is getting fetched

The app router supports features you already know from the pages router, like dynamic or catch all route segments, but offers more features today and even more new features got added since the first release like the parallel routes that got introduced in Next.js 13.3

> [!MORE]  
> [Next.js "pages routing" documentation](https://nextjs.org/docs/pages/building-your-application/routing)  
> [Next.js "app routing" documentation](https://nextjs.org/docs/app/building-your-application/routing)  
> [Next.js "routing files" documentation](https://nextjs.org/docs/getting-started/project-structure#routing-files)  

### layout(s) in pages VS app

With the [pages router layouts](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts), you have the possibility to wrap the **children** prop in your `_app.tsx` with a layout component which then gets applied to every page, if however you want to use more than one layout, then you have to write custom code to make it work, for example by adding custom code inside of your _app.tsx you could check which route you are on and based on that switch to another layout, or you could import different layout components in each page file

With the [app router layouts](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts), it is much easier to have different layouts for different segments of your website, all you need to do is add layout.tsx (layout.jsx) into a directory and it will apply to the segment it is in as well as all segments nested below that, so not only is it easy to have multiple layouts it is also easy to create a cascade of nested layouts

So even the app router layout system does NOT come with a lot of new features (the page layout system is already quite feature rich), in my opinion the DX got improved by a lot and hence it is easier to manage complex scenarios

> [!MORE]  
> [Next.js "pages router layout" documentation](https://nextjs.org/docs/pages/building-your-application/routing/pages-and-layouts)  
> [Next.js "app router layout" documentation](https://nextjs.org/docs/app/building-your-application/routing/pages-and-layouts)  

### data fetching and rendering 

#### using the pages router

Here is a little recap of the 1st and 2nd generation of data fetching features using the pages router (in the **pages** directory):

* first there was [getInitialProps](https://nextjs.org/docs/pages/api-reference/functions/get-initial-props), because the first page gets rendered on the server, **getInitialProps** would be called on the server, then if visiting another page using next/link or next/router that second page would get generated in the client, so any code in getInitialProps would this time get executed on the client side. This however meant that you had to be aware if you were currently on the server and could use server side code to make a direct call to the database (to fetch data) or if you were in the client and hence had to fetch the data via an ajax call (to an API endpoint). Besides that it was also important to be careful about how and what packages you were importing as you might have been using a package in your getInitialProps on the server but did not want it to also get imported when getInitialProps runs in the client. This is why biggest pain point was that if you wanted to avoid that some server dependencies leak into the client code, then you had to exclude those packages from the client by either using dynamic imports encapsulated into conditions (that would check if the code is being executed on the server or the client and based on that decide to call the dynamic import or not), or you had to use bundler plugins that would automatically exclude those "server only" packages at build time for you.
* the newer [getServerSideProps](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-server-side-props) (which first appeared in march 2020 with [Next.js 9.3](https://nextjs.org/blog/next-9-3)) is an async function that fetches the data and populates the props object of your page function. Same as with getInitialProps for the first page the code gets executed on the server, but if you visit a second page **getServerSideProps** will again get executed on the server and the data it returns will get sent as JSON to the client. Using getServerSideProps instead of getInitialProps eliminates two pain points, first you do not have to care about your imports anymore as next.js will exclude those "server only" packages for you from client bundle automatically and the second pain point it eleminates is that you do NOT have to write extra "fetch data" code in the client as Next.js will call getServerSideProps on the server for you and then fetch the data as JSON.
* [getStaticProps](https://nextjs.org/docs/pages/building-your-application/data-fetching/get-static-props) appeared alongside getServerSideProps, the difference between the two is that getServerSideProps disables ["Automatic Static Optimization"](https://nextjs.org/docs/pages/building-your-application/rendering/automatic-static-optimization) but getStaticProps does not, **getStaticProps** is useful to fetch data not at "runtime" but at "build time", so when a user visits a page no data call is being made, all data got already fetched at build time (and the page props have been put in a static json file), which means for any request being made by a user your data won't change, this can be very interesting to build pages that load super fast as they use data that does not change between two builds, however getStaticProps has a feature so that you can "revalidate" data in the background, this is what gets used by "[Incremental Static Regeneration](https://nextjs.org/docs/pages/building-your-application/data-fetching/incremental-static-regeneration)" and allows you to update the static data you got at build time.

#### using the app router

To do **data fetching** in the **app Router** you do NOT use the getServerSideProps anymore, instead you use Server Components that fetch data on the server and then send it to the client, together with your pre-rendered client components and compiled css

In the app router (in my opinion) it is easier to get data from an API compared to using the getServerSideProps in pages (less framework specific syntax you need to know), a regular fetch will do (fetch in Next.js got extended with framework specific features like a caching mechanism, but in the end it still works like a regular fetch), here is a very simple example:

```jsx
export default async function MyPage() {
    const data = await fetch('https://api.example.com/...')
    return (<>{data.foo}</>)
}
```

When getting data in Server Component and you are calling an API endpoint, then it is highly recommended to use **fetch** as it will automatically cache the data request. You can fine tune the caching of requests by for example defining when the cache should expire by setting the revalidate value manually and you can even disable caching if you want / need to:

```jsx /{ next: { revalidate: 3600 } }/#special
export default async function MyPage() {
    // revalidate if cache older than an hour
    const data = await fetch(
        'https://api.example.com/...',
        { next: { revalidate: 3600 } }
    )
    return (<>{data.foo}</>)
}
```

It is also possible to use tags which are useful to request that multiple cached queries get revalidated all at once based on their common tag:

```jsx /{ next: { tags: ['collection'] } }/#special title="page.tsx"
export default async function MyPage() {
    // revalidate if cache older than an hour
    const data = await fetch(
        'https://api.example.com/...',
        { next: { tags: ['my_custom_tag'] } }
    )
    return (<>{data.foo}</>)
}
```

```jsx {6} title="action.ts"
'use server'
 
import { revalidateTag } from 'next/cache'
 
export default async function action() {
    revalidateTag('my_custom_tag')
}
```

> [!TIP]  
> I highly recommend to do a deep dive in the [Next.js "Data Fetching, Caching, and Revalidating" documentation](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating) to better understand how this works and what options you have.  

Now fetch is not the only way to get data in server components, you can also directly use a database client package or even an ORM, but in that case you need to setup the caching yourself by for example using [react cache](https://react.dev/reference/react/cache). There is more information in the Next.js documentation about [fetching data on the server with third-party libraries](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating#fetching-data-on-the-server-with-third-party-libraries).

```jsx
import { cache } from 'react'
import { client } from 'third_party_database_client'
 
export const getData = cache(async (id) => {
    const data = await client.queryById({ id })
    return data
})

export default async function MyPage({ params: { id } }) {
    const data = await getData(id)
    return (<>{data.foo}</>)
}
```

Another option for caching database request got introduced in **Next.js 14** where it marked as unstable (so be aware that the API might change in the future), the new next/cache feature is called [unstable_cache](https://nextjs.org/docs/app/api-reference/functions/unstable_cache), it is the same caching mechanism used by fetch by for own queries using the database client you prefer:

```jsx
import { unstable_cache } from 'next/cache'
import { client } from 'third_party_database_client'
 
const getData = unstable_cache(async (id) => {
    const data = await client.queryById({ id })
    return data
}, ['my_custom_tag'])

export default async function MyPage({ params: { id } }) {
    const data = await getData(id)
    return (<>{data.foo}</>)
}
```

In version 14.1 Next.js got some improvements for [custom cache handlers](https://nextjs.org/docs/app/building-your-application/deploying#configuring-caching) which got released as stable version, (most useful when not deploying your project on Vercel and when using your own custom cache storage), the two configuration options are now called [cacheHandler](https://nextjs.org/docs/app/api-reference/next-config-js/incrementalCacheHandlerPath) and **cacheMaxMemorySize**:

```js title="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
    cacheHandler: require.resolve('./MY_CUSTOM_CACHE_HANDLER.js'),
    cacheMaxMemorySize: 0,
}
```

In version 14.2 the Next.js team added a new experimental option to called [staleTimes](https://nextjs.org/docs/app/api-reference/next-config-js/staleTimes) to let developers to set custom revalidation times for the [Router Cache](https://nextjs.org/docs/app/building-your-application/caching#router-cache):

```js title="next.config.mjs"
/** @type {import('next').NextConfig} */
const nextConfig = {
    experimental: {
        staleTimes: {
            dynamic: 30,
            static: 180,
        },
    },
}
```

In version 15 Next.js changed [caching](https://nextjs.org/blog/next-15-rc#caching-updates) to be disabled by default, meaning you now need to opt-in caching manually

> [!MORE]  
> [Next.js "Data Fetching, Caching, and Revalidating" documentation](https://nextjs.org/docs/app/building-your-application/data-fetching/fetching-caching-and-revalidating)  
> [Next.js "unstable_cache" API reference](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)  
> [React "Cache (Server components)" documentation](https://react.dev/reference/react/cache)  
> [Vercel "Fetching data faster with the App Router" article](https://vercel.com/blog/nextjs-app-router-data-fetching)  
> [Next.js "Configuring Caching" documentation](https://nextjs.org/docs/app/building-your-application/deploying#configuring-caching)  
> [Next.js "Router Cache" documentation](https://nextjs.org/docs/app/building-your-application/caching#router-cache)  
> [Next.js 15 "caching changes" blog post](https://nextjs.org/blog/next-15-rc#caching-updates)  

### server components and server actions

When using the app directory, Next.js (>= 13) will consider that every component is a **Server Component** by default, meaning if you don't specify anything then a component (or page / layout) with no directive (either 'use client' or 'use server') is **automatically considered being a Server Component**. There are things you can't do in a Server Component like using `useEffect{:js}` or listening for an `onClick{:js}` event, if you want to use these you need to add the 'use client' directive on top of your component turning your component into a client component.

It is recommended to turn as few componments into client components as possible, Next.js always has and still does render client components on the server, then sends the HTML to the client and finally does a hydration step to make the page interactive, however server components use a SSR technique called the React Server Component Payload (RSC Payload) that will result in less client code, which will result in reduced pageload times.

It is also recommended that you do all data fetching in Server Components as it allows you import packages that will only get used on the Server, meaning they will not get bundled with other client side code, hence reducing the payload that is being sent to the client. Another benefit is that you can use environment variables like an API key and those will stay secret and not be exposed to the client when you use them in Server Components.

**Server Actions** allow us to mutate data on the server (from within a client component) without for example having to call an API endpoint, by using the directive 'use server' inside client a component you turn a part of your client component into a Server Component and that code will get executed on the Server but resides inside of client component. This means that Server Actions have the potential to greatly simplify our code, for example using Server Actions allow you to update or insert data into a database next to the client code that handles the onSubmit of a form. Server Actions also make it easy to progressively enhance forms, meaning a form will be usable even before JavaScript has been loaded.

```jsx
'use client'

import { client } from 'my-database-lib'

export default function MyPage() {
    async function formAction(formData) {
        'use server'
        client.insert({ name: formData.get('username') })
    }
    return (<form action={formAction} method="POST">
        <input type="text" id="username">
    </form>)
}
```

Below I are links to documents I think will help to fully understand the potential of the **App router** data fetching, **Server Components** and **Server Actions**:

> [!MORE]  
> [Next.js "Server Components" documentation](https://nextjs.org/docs/app/building-your-application/rendering/server-components)  
> [Next.js "Server Actions and Mutations" documentation](https://nextjs.org/docs/app/building-your-application/data-fetching/server-actions-and-mutations)  
> [Next.js "rendering" documentation](https://nextjs.org/docs/app/building-your-application/rendering)  
> [Next.js "App Router common mistakes and how to fix them" blog post](https://vercel.com/blog/common-mistakes-with-the-next-js-app-router-and-how-to-fix-them)  
> [Next.js "Server Components and Server Actions Security" blog post](https://nextjs.org/blog/security-nextjs-server-components-actions)  
> [Vercel "Understanding React Server Components" article](https://vercel.com/blog/understanding-react-server-components)  

</article>
