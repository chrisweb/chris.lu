%toc%

<article>

# Content Security Policy (CSP)

![banner image displaying displaying a female robocop, in front of a police car with the text CSP on the side door, in a futuristic city](../../../../public/assets/images/app/web_development/posts/csp/banner.png)

**Content Security Policy (CSP)** is important as it can help you prevent cross-site scripting (XSS), clickjacking, and other code injection attacks resulting from the execution of malicious content. That malicious content can be hiding in remote code from a banner ads system you included into your app or is for example hidden in a client package from a compromised NPM account.

Using the Content-Security-Policy HTTP header to limit fetching resources only from sources you explicitly declared can mitigate the risks related to content injection attacks. OWASP has an interesting [OWASP "Content Security Policy (CSP)" cheat sheet](https://chromium.googlesource.com/chromium/src/+/HEAD/net/reporting/README.md) page with examples that show you what kind of malicious atttacks the different CSP directives can help prevent

> [!MORE]  
> [MDN "Content Security Policy (CSP)" documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP)  
> [Wikipedia "Content Security Policy (CSP)" page](https://en.wikipedia.org/wiki/Content_Security_Policy)  
> [OWASP "Content Security Policy (CSP)" cheat sheet](https://chromium.googlesource.com/chromium/src/+/HEAD/net/reporting/README.md)  

## CSP policy using a meta element or header

There are two ways to define **CSP directives**, either you use a **header** sent by your server or you use the **meta element** in your html

A basic meta element to configure a CSP policy would look like this:

```html
<meta
    http-equiv="Content-Security-Policy"
    content="img-src 'self';" />
```

The header is often the preferred way of as it supports sending reports which is something that can't be done using the meta element

A very basic [Content-Security-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy) header looks like this:

```shell
Content-Security-Policy: img-src 'self'
```

So far we used the Content-Security-Policy header but there is a second header [Content-Security-Policy-Report-Only](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only) that can be used, the difference is that when using Content-Security-Policy the browser will enforce the policy, if using Content-Security-Policy-**Report-Only** the browser will only report violations but NOT enforce them

```shell
Content-Security-Policy-Report-Only: img-src 'self'
```

## CSP directives

The **default-src directive** is a fallback that gets used everytime a [fetch directive](https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive) for a resource type is missing, for a complete list check out the [MDN "CSP: default-src" documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/default-src)

I saw countless CSP examples (for beginners) that would set the **default-src** to **'self'**, my personal recommendation is set the default-src to **none** or even better don't set it at all (which is equivalent to setting it to none), meaning that it will disallow any source for any content type, which means you use a **secure by default** approach instead of an open everything by default one, like this:

```shell
Content-Security-Policy: default-src 'none'
```

Then I would check which violations get listed in your console log and then one by one use directives to fix the violations one resource type at a time, for example a policy to allow images from the same origin as the html document would look like this:

```shell
Content-Security-Policy: default-src 'none'; img-src 'self'
```

For a website that has images, javascript and css and where the javascript code needs to make requests to a remote API (api.example.com) I would use this basic CSP policy:

```shell
Content-Security-Policy: default-src 'none'; img-src 'self'; script-src 'self'; style-src 'self'; connect-src https://api.example.com
```

Not all policy directives are fetch directives, check out this [MDN directives documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy#directives) for a full list

## the state of violations reporting (as of february 2024)

CSP violations can not only be seen in the console, as this would limit us to only see violations that occur when we (the developers) visit the app ourself, but what about violations that happen when a user visits our project, for such cases you can use CSP violations reporting

However how CSP violation reports work has changed over the years, the w3c has released several iterations of their Content Security Policy recommendations / working drafts and then even created a drafts for something called the Reporting API which is a new header dedicated to sending reports to an endpoint

* in the [CSP level 1](https://www.w3.org/TR/2012/CR-CSP-20121115/) & [CSP level 2](https://www.w3.org/TR/CSP2/) recommandations, CSP violations get reported using a [report-uri](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri) reporting directive, if we look at [caniuse report-uri](https://caniuse.com/?search=report-uri) page we can see that it is supported by all major browsers
* [CSP level 3](https://www.w3.org/TR/CSP3/) introduces a new [report-to](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to) **reporting directive** and the w3c has marked the report-uri directive as deprecated, if we look at [caniuse report-to](https://caniuse.com/mdn-http_headers_content-security-policy_report-to) however we see that firefox does not yet support the directive, they actually now do have support for it but it is behind a feature flag (their ticket ["CSP: Implement report-to"](https://bugzilla.mozilla.org/show_bug.cgi?id=1391243) is quite old but some ago they seemed to have started working on it) and safari only started to support it with v16.4 (released March 27, 2023), chrome on the other hand has had support for report-to and the corresponding Report-To header (from the reporting API v0 specs) since [version 69](https://chromestatus.com/feature/4672626140119040) but dropped it in version 96 in favor of the more modern **Reporting-Endpoints** (introduced in the reporting API v1)

### report-uri

**report-uri** is a directive used to tell the browser where to send CSP violation reports, the w3c has marked it as deprecated but as of today this is still the only reporting mechanism that most SAAS logging services support and also the only directive supported by all major browsers

A Content Security header that uses the report-uri directive looks like:

```shell
Content-Security-Policy: ...;
    report-uri https://csp-logging.example.com
```

> [!MORE]  
> [MDN "CSP: report-uri" documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-uri)  
> [caniuse "report-uri" page](https://caniuse.com/mdn-http_headers_content-security-policy_report-uri)  
> [w3c "CSP level 1" working draft](https://www.w3.org/TR/2012/CR-CSP-20121115/)  
> [w3c "CSP level 2" working draft](https://www.w3.org/TR/CSP2/)  

### report-to != Report-to

If like me you read some documents about CSP you might find that there are two report-to, **report-to** (with a small first letter **r**) refers to the directive, this report-to directive can point to a Reporting API header, in the first version (v0) of the reporting API that header was called **Report-to** (with a capital **R**)

The **report-to** directive is part of the w3c [CSP level 3](https://www.w3.org/TR/CSP3/) reference and is still valid today

The **Report-to** header however, is part of an initial draft by the w3c for the [reporting API v0](https://www.w3.org/TR/2016/WD-reporting-1-20160407/#header), however this draft is now obsolete, if you see this header in a documentation it means that it is outdated

In the new [w3c "Reporting API v1" working draft](https://www.w3.org/TR/reporting-1/) the Report-to header got replaced by a header that is now called **Reporting-Endpoints**

### Reporting API

The **Reporting API** describes a new header that tells the browser which endpoint(s) should get used to send the reports

This header is NOT just to send CSP violations reports but covers a wide range of use cases, for example it can be used to send [Permissions-Policy](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy) reports, reports regarding deprecated browser features your code might be using, but also reports about browser crashes and more...

#### Reporting API v0

The first [reporting API v0 draft](https://www.w3.org/TR/2016/WD-reporting-1-20160407/#header) of the **Reporting API (v0)** included a new **Report-to** header

[chrome version 69](https://chromestatus.com/feature/4672626140119040) was the first browser to ship with support for the **Report-to** header and based on [caniuse "Report-to header"](https://caniuse.com/mdn-http_headers_report-to) neither Firefox nor Safari support it (yet)

An example of the Reporting API v0 (**deprecated**) using the report-to directive would look like this:

```shell
Content-Security-Policy: ...;
    report-uri https://csp-logging.example.com;
    report-to {"group":"default","max_age":10886400,"endpoints":[{"url":"https://csp-logging.example.com"}],"include_subdomains":true}
```

and using the Report-to header, like this:

```shell
Content-Security-Policy: ...;
    report-to default
Report-to: {"group":"default","max_age":10886400,"endpoints":[{"url":"https://csp-logging.example.com"}],"include_subdomains":true}
```

Did you notice the **max_age** key in the Report-to json, this tells the browser for how long you want to cache the endpoint information, meaning that if the next page (as long as the origin is the same) wants to make a report you don't need to specify the endpoint again and can just use it in the directive, this feature however got dropped in the v1 specs of the reporting API

> [!MORE]  
> [MDN "CSP: report-to" documentation](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to)  
> [caniuse "report-to directive" page](https://caniuse.com/mdn-http_headers_content-security-policy_report-to)
> [caniuse "Report-To header" page](https://caniuse.com/mdn-http_headers_report-to)  

#### Reporting API v1

After a while the w3c team decided to rename the header and so in the [w3c "Reporting API v1" working draft](https://www.w3.org/TR/reporting-1/) they renamed the Report-to header to **Reporting-Endpoints**

[chrome 96](https://chromestatus.com/feature/5712172409683968) is the first browser to ship support for the **Reporting-Endpoints** header

> [!NOTE]  
> There is a very good article on developer.chrome.com you may want to read with lots of additional information about the new Reporting API Endpoints titled [Monitor your web application with the Reporting API](https://developer.chrome.com/docs/capabilities/web-apis/reporting-api) and they also have a [Reporting API v0 to v1 migration guide](https://developer.chrome.com/blog/reporting-api-migration)  

An example of a header using the new Reporting-Endpoints header for CSP violations:

```shell
Content-Security-Policy: ...; report-to default
Reporting-Endpoints: default="https://csp-logging.example.com"
```

You can specify more then one endpoint if you need to:

```shell
Reporting-Endpoints: default="https://csp-logging.example.com", second-endpoint="https://csp-logging2.example.com"
```

> [!MORE]  
> [chrome developer "Monitor your web application with the Reporting API" article](https://developer.chrome.com/docs/capabilities/web-apis/reporting-api)  
> [chrome developer "Migrate to Reporting API v1" article](https://developer.chrome.com/blog/reporting-api-migration)
> [MDN "Reporting API" documentation](https://developer.mozilla.org/en-US/docs/Web/API/Reporting_API)  
> [caniuse "Reporting API" page](https://caniuse.com/?search=Reporting%20API)  
> [w3c "Reporting API v1" working draft](https://www.w3.org/TR/reporting-1/)  
> [chromium "Reporting API" readme](https://chromium.googlesource.com/chromium/src/+/HEAD/net/reporting/README.md)  

## logging CSP violations

A lot of the paid SAAS Error Monitoring services can also be used to log CSP violations, [Sentry.io CSP logging documentation](https://docs.sentry.io/product/security-policy-reporting/), [raygun.com](https://raygun.com/documentation/language-guides/browser-reporting/crash-reporting/csp/) or [datadoghq.com](https://www.datadoghq.com/blog/content-security-policy-reporting-with-datadog/)

An alternative is to host a logging tool on your own infrastructure, for example Mozilla published an opensource [CSP logging service called "CSP Logger"](https://github.com/mozilla/csp-logger) on GitHub that is written in Javascript but it only supports the report-uri directive and has not been updated in years

Or you could write your own CSP logging endpoint and store the reports in a database but then you probably will also need an admin interface to filter and analyze the reports

> [!MORE]  
> [Mozilla "CSP Logger" repository](https://github.com/mozilla/csp-logger)  

### logging CSP violations using Sentry.io

Sentry.io can be used to log CSP violations and will add those to your project issues

Sentry.io also supports [Certificate Transparency](https://developer.mozilla.org/en-US/docs/Web/Security/Certificate_Transparency) reports logging and [HTTP Public Key Pinning (HPKP)](https://developer.mozilla.org/en-US/docs/Glossary/HPKP), however both those features are now obsolete

> [!MORE]  
> [Sentry.io "Security Policy Reporting" documentation](https://docs.sentry.io/product/security-policy-reporting/)  

#### Sentry.io does not the Reporting-Endpoints header (yet)

The repoting API v1 **Reporting-Endpoints** header is not yet supported by sentry.io, there are several open tickets related to this, one of them is [issue #38940](https://github.com/getsentry/sentry/issues/38940)

#### Sentry.io (by default) has a filter for reports coming from localhost

Your localhost requests might get filtered by Sentry.io if you or a team member have enabled that feature, if you use **report-uri** you will see the successful requests in the Network tab but they won't show up in Sentry.io

If you want to **report-uri** CSP reports from localhost

* visit Sentry.io and log in
* in the left navigation on the bottom click on **Settings**
* Then in the Settings navigation on the left click on **Projects**
* Click on the project name
* Then in navigation on the left, under **PROCESSING**, click on **Inbound Filters**
* On that page there is an option called **Filter out events coming from localhost** disable that option to not filter reports coming from localhost anymore

> [!TIP]  
> You probably don't want to keep that enabled for too long as developing locally will generate all sorts of error logs that are not very useful, so just remember to turn the filter back on when you don't need the localhost reports anymore

### Sentry.io documentation example is not ideal

The Sentry.io documentation suggests you add the Reporting API v0 as fallback for the report-uri directive, like so:

```shell
Content-Security-Policy: ...;
    report-uri https://xxx.ingest.sentry.io/api/007/security/?sentry_key=aaa;
    report-to csp-endpoint

Report-To: {"group":"csp-endpoint","max_age":10886400,"endpoints":[{"url":"https://xxx.ingest.sentry.io/api/007/security/?sentry_key=aaa"}],"include_subdomains":true}
```

The problem is that chrome (>96) will attempt to use the new **report-to directive**, but chrome (>96) supports the **Reporting-Endpoints** header from the Reporting API v1 and not the **Report-To** header defined in Reporting API v0 specs, so it will fail sending the reports and then it will never fallback to using the report-uri directive, meaning that if you use this suggested setup you will not get any reports from chrome (>96) at all

I instead suggest online using the report-uri directive for the time being and only add the report-to directive in the future when browser support for that feature has significantly improved

> [!MORE]  
> [Sentry.io "Content-Security-Policy reporting" documentation](https://docs.sentry.io/product/security-policy-reporting/)  
> []

## CSP debugging tips

### Reduce chrome CSP reporting delay

Chrome will wait some time to ensure it collected all the potential CSP reports before attempting to send them to the reporting server, there is however a command-line switch that you can use to shorten that delay when debugging CSP reporting

> [!WARN]  
> This option is NOT a Flag it is a command line option

On Mac or Linux, to shorten this delay to a minimum you can use the following command in your terminal to manually start chrome:

```shell
PATH/TO/Chrome --short-reporting-delay
```

On Windows if you use PowerShell then the command syntax is a bit more complex:

```shell
Start-Process -FilePath 'C:\Program Files (x86)\Google\Chrome\Application\chrome.exe' -ArgumentList '--short-reporting-delay'
```

> [!MORE]  
> [Chromium "Run Chromium with command-line switches" documentation](https://www.chromium.org/developers/how-tos/run-chromium-with-flags/)

### report-uri works in localhost but report-to does NOT

When using **report-uri**, reporting violations works locally (localhost) as well as in preview / production (secure context / https URL)

When using **report-to**, reporting violations will NOT work on localhost (in chrome) without a valid SSL certificate, which is surprising as localhost usually is considered a secure context (if you know why please let me know using the [chris.lu github discussions](https://github.com/chrisweb/chris.lu/discussions))

In staging (preview) / production environements however the **report-to** will work as long as those environments have an SSL certificate

#### report-uri requests show up in the Network tab

When using **report-uri** directive, you can inspect requests using the developer tools **Network tab** like any other POST request made by your app

#### report-to requests are Not in the Network but the Application tab

When using **report-to** directive, you won't see any entries in your developer tools **Network** tab, this is because a background service does the request(s) and not the website (your code)

To see the requests open your developer tools, then click on the **Application** tab and then on the left list under **Background services** click on **Reporting API**:

![](../../../../public/assets/images/app/web_development/posts/csp/developer_tools_application_reporting_api.png)

### adblockers may block CSP violation logging services

If you are using report-uri and your logging tool does not recieve the reports then they might be **blocked**, to verify if the requests are blocked, open your browsers developer tools and then go into the Network and check if their **status is blocked**, in which case you probably have an adblocker extension installed that is blocking the requests, I for example use [Privacy Badger](https://privacybadger.org/) and have to allow the domain in the extension settings

![](../../../../public/assets/images/app/web_development/posts/csp/privacy_badger_sentry_ingest_blocked.png)

so make sure to either whitelist the Sentry.io CSP reporting URL or disable the adblocker for your domain or even diable it completly until you are done testing

### Chrome (Chromium) CSP preflight request headers BUG

This bug is important if you want to create your own CSP logging server

There is a bug in Chrome (Chromium) which will cause Preflight requests to fail if some of the reponse headers use a wildcard

Chrome will send make a call to your server using the OPTIONS method to test your endpoint before sending the actual reports, but if your server response has headers with an Asterisk then the preflight request will fail

So for example these headers will NOT work:

```js
headers["Access-Control-Allow-Origin"] = "*";
responseHeaders["Access-Control-Allow-Methods"] = "*";
responseHeaders["Access-Control-Allow-Headers"] = "*";
```

But these will work:

```js
headers["Access-Control-Allow-Origin"] = request.headers.origin;
responseHeaders["Access-Control-Allow-Methods"] = "POST";
responseHeaders["Access-Control-Allow-Headers"] = "Content-Type";
```

Have a look at the [chromium issue #40733909](https://issues.chromium.org/issues/40733909) if you want more details and maybe you are lucky and it got fixed

### Create a quick and dirty CSP reporting server

To help me better understand what kind of information browsers send when using the different version of CSP reports I wrote a small Node.js server tool to display some information about CSP logging calls

If you want to set up a CSP logging server for yourself you can use the following code to get you started:

```js title="csp-logging.mjs"
import { createServer } from 'node:http';
import url from 'node:url';

// https://nodejs.org/en/learn/modules/anatomy-of-an-http-transaction

const server = createServer((request, response) => {

    const { headers, method, url: requestUrl } = request;
    const parsedUrl = url.parse(requestUrl, true);
    const query = parsedUrl.query;
    const path = parsedUrl.pathname;

    console.log('parsedUrl: ', parsedUrl);
    console.log('query: ', query);
    console.log('path: ', path);
    console.log('method: ', method);
    console.log('headers: ', headers);

    if (method === 'OPTIONS') {
        const responseHeaders = {};
        // TODO: check if origin is in whitelist
        headers["Access-Control-Allow-Origin"] = request.headers.origin;
        responseHeaders["Access-Control-Allow-Methods"] = "POST";
        responseHeaders["Access-Control-Allow-Credentials"] = false;
        //headers["Access-Control-Max-Age"] = '86400'; // 24 hours
        responseHeaders["Access-Control-Max-Age"] = '300'; // 5 minutes (for testing)
        responseHeaders["Access-Control-Allow-Headers"] = "X-Requested-With, X-HTTP-Method-Override, Content-Type, Accept";
        response.writeHead(200, responseHeaders);
        response.end();
    } else {

        let body = [];

        request
            .on('error', err => {
                console.error(err);
            })
            .on('data', chunk => {
                body.push(chunk);
            })
            .on('end', () => {
                body = Buffer.concat(body).toString();
                console.log('body: ', body);
            });

        //response.writeHead(200, { 'Content-Type': 'text/plain' });
        //response.end('Hello World!\n');

        response.statusCode = 200;
        response.end();
    }

});

// starts a simple http server locally on port 3000
server.listen(3000, '127.0.0.1', () => {
    console.log('Listening on 127.0.0.1:3000');
});
```

To start the server use the following command:

```shell
node csp-logging.mjs
```

If you need to setup a server to host the Node.js server you might want to have a look at my [Tutorial: Node.js server on an AWS EC2 instance with an NGINX reverse proxy](/web_development/tutorials/node-js-app-aws-ec2/)

### Debugging Sentry.io dropping reports

While testing the CSP reporting feature on Sentry.io I had trouble to understand why some reports would not go through

In the **Stats** page on Sentry.io I would only see that a certain amount of requests had been dropped but not for what reason

If you want to get a little bit more information as to why requests get dropped you can use the Sentry.io API, I recommend having a look at the [Sentry.io API chapter in my Sentry.io Post](/web_development/posts/sentry-io/#investigating-sentryio-dropped-requests)

### Debugging chrome requests using Netlog

> [!WARN]  
> Before you start experimenting with Chrome Netlog, know that as of now the information you get from the logs is not very helpful, you still can't see the exact reason as to why a CSP report call has failed, but hopefully future version will bring improvements, this is why I added this option to this post

Debugging the reporting API in chrome is painful as you don't get any information about why requests have failed, the requests will just go back to a **Queued** state if the fail and chrome will retry to send the report, if sending the reports fails for a while chrome will show a "MarkedForRemoval" state

Chrome (Chromium) has a tool called [Netlog](https://www.chromium.org/developers/design-documents/network-stack/netlog/):

> NetLog is an event logging mechanism for Chromeâ€™s network stack to help debug problems

You can access Netlog by entering the following URL into your address bar:

```shell
chrome://net-export/
```

Now click on the **Start Logging To Disk** button and then in another tab open the website making the CSP reporting calls

Then after a while click on **Stop Logging**

To analyze the content of the log file head over to the [Netlog viewer website](https://netlog-viewer.appspot.com/) that google has created to help you analyze logs

Then in the left navigation click on **Reporting**

> [!MORE]  
> [Chromium "NetLog" documentation](https://www.chromium.org/for-testers/providing-network-details/)  
> [Google "Netlog viewer" page](https://netlog-viewer.appspot.com/)  

</article>
