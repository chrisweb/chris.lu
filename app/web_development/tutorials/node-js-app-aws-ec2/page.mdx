%toc%

<article>

# Tutorial: Node.js app deployment on AWS EC2 instance with NGINX reverse proxy

![banner image displaying a young man in the clouds working on his laptop](../../../../public/assets/images/app/web_development/tutorials/node-js-app-aws-ec2/banner.png)

In this tutorial we will:

* create a new AWS EC2 instance with Amazon Linux 2023
* install Node.js LTS using the Node Version Manager (NVM)
* setup a remote Proxy server using NGINX and configure a custom domain
* fetch the source code of our app from its GitHub repository

## Prerequisites

TODO: when finalizing this article check out the Ec2 aws documents I did for beavo, maybe there are things that can be added from those

go to aws.amazon.com and either sign in (if you already have an account) or click on **create a new account** in the top right

## ec2 instance

Visit [https://aws.amazon.com/](https://aws.amazon.com/) and login into your account

Now in the top left search field type **ec2** and then click on **EC2** (Virtual Servers in the Cloud)

> [!TIP]  
> In the top right next to your username make sure you have the region selected in which you want to create a ec2 instance, either chose the one that is the closest to you (the closer the server is to your location the faster the connection will be) or chose a region that is cheap (not every region has the same costs, so you may want to check out the [ec2 (on demand) pricing](https://aws.amazon.com/ec2/pricing/on-demand/) first and decide based on that)

then click on the orange button **Launch instance**

TODO: steps to create ec2 micro with amazon linux 2023
TODO: make sure the security group has the port 80 open, when making a test I had a security group,with only the ssh port 22 and ssl port 443 open, which made it impossible to set up the ssl certificate

## DNS setup using route 53

in the top left search field type **53** and then click on **Route 53** (Scalable DNS and Domain Name Registration)

click on Hosted zone(s)

click on the button **Create hosted zone**

TODO: steps to create a hosted zone

## Change the nameservers of your domain

Next you need to change the nameservers of your domain so that the domain uses the AWS Route 53 DNS setup we just did

Every domain name reseller has a slightly different interface, but usually the procedure is something like this:

* login on the website of your domain name reseller
* go to your domains page
* click on the domain name you want to edit
* click on manage nameservers
* if there are already nameserver listed, deleted those first
* then login into AWS and go to Route 53
* copy the 4 nameservers from AWS
* add the 4 nameserver to your domain (on the domain resellers website)
* click save

> [!MORE]  
> ["change domain nameservers" on name.com](https://www.name.com/support/articles/205934547-changing-nameservers-for-dns-management)  
> ["change domain nameservers" on gandi.net](https://docs.gandi.net/en/domain_names/common_operations/changing_nameservers.html)  
> ["change domain nameservers" on domains.google.com](https://support.google.com/domains/answer/3290309)  
> ["change domain nameservers" on namecheap.com](https://www.namecheap.com/support/knowledgebase/article.aspx/767/10/how-to-change-dns-for-a-domain/)  

## putty

### install putty

I'm on windows so I will use putty (if you are on a Mac or Linux you will probably want to use ssh)

install the [latest version of putty](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html)

### connect to server (ec2 instance)

TODO: steps to create a new session in putty

### increase keep alive of putty connections

to avoid losing the server connection after a short period of time (putty time out) you can set a keep alive in putty to keep the connection open

to do so select your session and then click on **Load**

then on the left click on **Connection**

then in the field **Seconds between keepalives** (which is probably currently set to 0) enter 240

now on the left click on **Session** and then **Save** to save the changes we just did

## install nvm

just to be sure, use dnf (or yum) to update the currently installed packages to the latest version using this command:

```shell
sudo dnf update
```

or if you prefer using yum (the predecessor of dnf):

```shell
sudo yum update
```

next we will use the [Node Version Manager](https://github.com/nvm-sh/nvm) (NVM) to install the latest Node.js LTS

go to [NVM releases page on github](https://github.com/nvm-sh/nvm/releases) and check out which is the latest version available

use the following command to start the NVM installation, but replace **** with the version you found on github 

```shell
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/LATEST_NVM_VERSION/install.sh | bash
```

after replacing the version the command will be something like this:

```shell
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
```

then load nvm using this command:

```shell
source ~/.bashrc
```

to verify what NVM version got installed you can use this command:

```shell
nvm --version
```

and now install nvm using this command:

```shell
nvm install --lts
```

> [!NOTE]  
> you can install multiple Node.js versions at a time (in parallel) but only use one at a time

to switch between versions use the command `nvm use NODE_JS_VERSION{:shell}` so for example:

```shell
nvm use 20.11.1
```

which will switch to that version (as long as it is a version you have previously installed) and then print a message like this:

```shell
Now using node v20.11.1 (npm v10.2.4)
```

to know which versions are installed (and / or available) you can use this command:

```shell
nvm list
```

to verify what Node.js version got installed you can use this command:

```shell
node -v
```

> [!MORE]  
> [AWS "Setting Up Node.js on an Amazon EC2 Instance" documentation](https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/setting-up-node-on-ec2-instance.html)

## NGINX installation

Next we will install NGINX to use it as reverse proxy (NGINX will listen on port 80/443)

```shell
sudo dnf install nginx
```

this will give you a list of what will be installed, then type `y{:shell}` and press `Enter{:shell}` to start the installation

next we will **enable** NGINX

> [!NOTE]  
> **enabling** a service means it will start at boot automatically (meaning if you server crashes and needs to be restarted, then on boot the service like NGINX will get automatically restarted too without you having to do so manually), we will do so using **systemctl ** which is the systemd command for controlling how services start on a Linux system

to enable NGINX use the following command:


```shell
sudo systemctl enable --now nginx
```

> [!NOTE]  
> we used the systemctl **--now** switch to also start NGINX, depending on the systemctl version now might not be supported (now got added in systemctl version 220, to check what version you have you can use this command `sudo systemctl --version{:shell}`), am AWS Linux 2023 it is, which is why we can use it here, if now is not supported you can use the `sudo systemctl start nginx{:shell}` command to start it manually

if you want to verify that NGINX is now enabled you can use this command:

```shell
sudo systemctl is-enabled nginx
```

and to check the nginx status (is it running?) you can use this command:

```shell
sudo systemctl status nginx
```

you should see a green message that says **active (running)**

## NGINX server configuration

next we will create a server configuration to instruct NGINX to act as reverse proxy for our Node.js app and to setup the domain name

Before we edit the nginx configuration file, let’s do a backup that we can restore if needed:

```shell
sudo cp /etc/nginx/nginx.conf /etc/nginx/nginx.conf.old
```

to edit the main NGINX configuration file use this command:

```shell
sudo vi /etc/nginx/nginx.conf
```

first locate the **http** block, and then find the **keepalive_timeout** line, go to the end of that line

then press the `i{:shell}` key to **enter insert mode**

then press the right arrow `→{:shell}` key and then `Enter{:shell}` to go to the new line

then add **client_max_body_size** (http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size) and set it to the value you require, this will increase the allowed size for uploads, if you don’t set it the default will be 1MB (which might be enough for your requirements, in which case you can skip this step), for my use case I set it to 50MB, like so:

```shell
client_max_body_size 50m;
```

to **exit insert mode** press the `ESC{:shell}` key

Under that line we add another option to disable the header that exposes the nginx version, I prefer to give malicious people the least information possible which is why I prefer NOT giving away the exact NGINX version that is installed by turning the server token off:

use the same steps as before to add a new line and go into insert mode, and then insert this line:

```shell
server_tokens off;
```

your configuration should not look like this:

```shell title="/etc/nginx/nginx.conf"
    sendfile            on;
    tcp_nopush          on;
    keepalive_timeout   65;
    client_max_body_size 50m;
    server_tokens off;
    types_hash_max_size 4096;
```

Next we add a line to tell nginx to include our own host files we are about to create, over the first server directive you should see the following line:

```shell
include /etc/nginx/conf.d/*.conf;
```

Under that line add the following line:

```shell
include /etc/nginx/sites-enabled/*.conf;
```

your configuration should not look like this:

```shell
    include /etc/nginx/conf.d/*.conf;

    include /etc/nginx/sites-enabled/*.conf;
```

Next you should comment out the default http server (or if you prefer delete those lines, we did a backup of this file anyway), by adding a # (number sign) in front of every line, so that it looks like this:

```shell
#    server {
#        listen       80;
#        listen       [::]:80;
#        server_name  _;
#        root         /usr/share/nginx/html;
#
#        # Load configuration files for the default server block.
#        include /etc/nginx/default.d/*.conf;
#
#        error_page 404 /404.html;
#        location = /404.html {
#        }
#
#        error_page 500 502 503 504 /50x.html;
#        location = /50x.html {
#        }
#    }
```

the https one should already be commented out, if it is NOT commented out yet, comment it out too

make sure you are not in insert mode by pressing the `ESC{:shell}` key

Then save and exit by typing `:x!{:shell}` and then press `Enter{:shell}`

Now we are going to create two new directories inside of /etc/nginx, one directory is called “sites-available” and it will contain the configuration file for our host(s), the second one is called “sites-enabled” and it will contain symbolic links to the configuration files we want to enable:

```shell
sudo mkdir /etc/nginx/sites-available
sudo mkdir /etc/nginx/sites-enabled
```

> [!NOTE]  
> in the main nginx configuration file we instructed nginx to look into the folder /etc/nginx/sites-enabled to find host configuration files, in that folder we will however not put the actual configuration files but symbolic links (symlinks) to the actual configuration files that we will create inside of sudo mkdir /etc/nginx/sites-available. This means that all host configuration files that are available no matter if they are currently being used or not will be in sites-available. Now if we want to use a configuration file we will add a symbolic link to it inside of sites-enabled, meaning it will then be enabled and nginx will follow the symbolic link to the actual configuration file. This allows us to quickly disable a host by deleting the symbolic link and reloading the nginx configuration, without actually deleting or altering the actual configuration file. Then later if we want to re-enable that host all we need to do is create a new symbolic link and reload the nginx configuration file.

Let’s create one such host configuration file by creating a file called chrisweb.dev.conf inside of /etc/nginx/sites-available using this command:

```shell
sudo vi /etc/nginx/sites-available/chrisweb.dev.conf
```

then press the `i{:shell}` key to **enter insert mode**

and then add add the following content (you can copy the following lines and then in putty press the right mouse key to paste), replace YOUR_DOMAIN_NAME with your domain name, something like **example.com**:

```shell title="/etc/nginx/sites-available/chrisweb.dev.conf"
server {
    listen       80;
    listen       [::]:80;
    server_name YOUR_DOMAIN_NAME; 

    location / {
        proxy_pass http://127.0.0.1:3000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

then press the `ESC{:shell}` key to **exit insert mode**

then type `:x!{:shell}` and then press `Enter{:shell}` to save the file

> [!NOTE]  
> we use the default localhost IP (127.0.0.1) and port 3000 in the configuration above, if your app is listening on another port then you need to modify that value, also as IP we use the localhost but if your nodejs is on a remote server then you need to change the IP address too

Now we can add a symbolic link in sites-enabled pointing to the configuration in sites-available to **enable** that configuration (as nginx will look up all configuration files in sites-enabled), to create the symlink use this command:

```shell
sudo ln -s /etc/nginx/sites-available/chrisweb.dev.conf /etc/nginx/sites-enabled/chrisweb.dev.conf
```

> [!TIP]  
> To later quickly disable a domain (configuration) just remove the symbolic link and reload the nginx configuration, to re-enable it just re-create the symbolic link (and leave the actual configuration in sites-available untouched)

To test the configuration file, you can use the following command:

```shell
sudo nginx -t
```

To reload the configuration use the following command:

```shell
sudo nginx -s reload
```

> [!TIP]  
> After a configuration change it is preferred to use reload instead of restart, reload will spawn a worker processes using your new configuration and then stop the old worker processes, which means that nginx will always be up and processing requests without interruption

Reload only works if NGINX is already running, if NGINX was stopped and you reload it will throw an error that it can't find the pid, in that case use the following command to start NGINX:

```shell
sudo systemctl start nginx
```

To check if NGINX is running use this command:

```shell
sudo systemctl status nginx
```

## Let's Encrypt SSL certificate installation using Certbot

We are going to add a [Let’s Encrypt](https://letsencrypt.org/) SSL certificate for our domain, to do so we will use the [Certbot](https://certbot.eff.org/) by the [Electronic Frontier Foundation](https://www.eff.org/)

To install the certificate we will use [pip](https://pip.pypa.io/en/stable/) (the python package manager), if you prefer you can also use [Snap](https://snapcraft.io/) (which is currently the [recommeded way of insalling certbot](https://eff-certbot.readthedocs.io/en/latest/install.html)) by checking out the [Snapd Fedora install instructions](https://snapcraft.io/docs/installing-snap-on-fedora) (I added a link to the fedora instrcutions as there are no specific Amazon Linux 2023 but [AL2023 is based on Fedora](https://aws.amazon.com/linux/amazon-linux-2023/faqs/)) and then the check out the [Install Certbot using Snap instructions](https://certbot.eff.org/instructions?ws=nginx&os=snap)

The certificate we will install will be for the domain only, if you want a wildcard certificate follow the [instructions provided on the certbot website](https://certbot.eff.org/instructions?ws=nginx&os=pip&tab=wildcard)

First we need to install [Python](https://www.python.org/) version 3 (if python is already installed it will get skipped) and a package called [augeas-libs](https://augeas.net/) (used to parse configuration files), to do so use the following command:

```shell
sudo dnf install python3 augeas-libs
```

Now we can use the following command to set up a virtual environment:

```shell
sudo python3 -m venv /opt/certbot/
```

Then we install pip (a tool used to install python packages), using this command:

```shell
sudo /opt/certbot/bin/pip install --upgrade pip
```

Now using pip we install certbot and the NGINX certbot plugin, using this command:

```shell
sudo /opt/certbot/bin/pip install certbot certbot-nginx
```

Next we use a symlink so that the user only needs to type "certbot" instead of the full path to use it, using this command:

```shell
sudo ln -s /opt/certbot/bin/certbot /usr/bin/certbot
```

Now we can finally request a certificate for the domain we added to the NGINX configuration and let certbot edit the configuration to server traffic over HTTPS:

```shell
sudo certbot --nginx
```

You will get asked some questions by the certbot cli tool

* do you wan't to provide your your email address (which will get used if your certificate is about to expire and has not been automatically renewed)
* Do you accept the terms and conditions
* Do you want to share your email with the [Electronic Frontier Foundation](https://www.eff.org/) so that they can periodically send you mails about their work 
* select the domains for which you want to install a certificate

After your certificate has been installed you can open the domain configuration file again and will see that certbot automatically added the HTTPS configuration:

```shell
sudo vi /etc/nginx/sites-available/chrisweb.dev.conf
```

To exit the file without saving enter `:q!{:shell}` and then press `Enter{:shell}` to exit the file

Now if you want to test the quality of your SSL certificate setup, you can do so using the free [Qualys SSL Server Test](https://www.ssllabs.com/ssltest/index.html)

> [!MORE]
> [certbot "domain (default) certificate, certbot setup" documentation](https://certbot.eff.org/instructions?ws=nginx&os=pip)
> [certbot "wildcard certificate, certbot setup" documentation](https://certbot.eff.org/instructions?ws=nginx&os=pip&tab=wildcard)
> [python.org "Installing Packages" documentation](https://packaging.python.org/en/latest/tutorials/installing-packages/)

### Periodically check for expired certificate(s) and automatically renew them

One last important thing, as certificates are shortlived we want to set up a recurring task that will to automatically renew our certificate(s) (when certbot detects that it is close to expering)

Let's start by testing if renewing a certificate works by launching a dry run (dry runs don't actually renew certificates they just simulate a renew):

```shell
sudo certbot renew --dry-run
```

If successful you will see a message that says:

> Congratulations, all simulated renewals succeeded

#### systemd timer OR cronjob

> [!NOTE]  
> Amazon Linux 2023 does pre-install cronie (as they explained in a [ticket on github](https://github.com/amazonlinux/amazon-linux-2023/issues/300#issuecomment-1481592973)), instead they use [systemd timers](https://wiki.archlinux.org/title/systemd/Timers)

I documentated both ways of doing it, either using a **systemd timer** or a **cronjob** (cronie), chose which you like best:

##### Using systemd timer

Now that we know that renewals work, lets create a service file for our systemd timer:

```shell
sudo vi /lib/systemd/system/certbot.service
```

And then paste the following content into the file:

```yaml title="/lib/systemd/system/certbot.service"
[Unit]
Description=Certbot renew

[Service]
Type=oneshot
ExecStart=/usr/bin/certbot renew -q
```

Then we create a second file which is the actual timer:

```shell
sudo vi /lib/systemd/system/certbot.timer
```

And add the following content into it:

```yaml title="/lib/systemd/system/certbot.timer"
[Unit]
Description=Run certbot twice a day

[Timer]
OnCalendar=*-*-* 00,12:00:00
RandomizedDelaySec=43200
Persistent=true

[Install]
WantedBy=timers.target
```

Finally, we use the following command to enable and start the certbot systemd timer:

```shell
sudo systemctl enable --now certbot.timer
```

To check if the timer is actually running use:

```shell
systemctl status certbot.timer
```

##### Using cronjobs (cronie)

If instead of **systemd timers** you prefer to use a cron then do the following:

To install cronie now, we use the follwing command:

```shell
sudo dnf install cronie
```

This will install cronie and cronie anacron

Then we enable and start it using:

```shell
sudo systemctl enable --now crond.service
```

And finally we add a line to the `/etc/crontab` file to tell certbot to check every 12 hours for certificates that are about to expire and if it finds one renew it automatically: 

```shell
echo "0 0,12 * * * root /opt/certbot/bin/python -c 'import random; import time; time.sleep(random.random() * 3600)' && sudo certbot renew -q" | sudo tee -a /etc/crontab > /dev/null
```

### updating certbot

In the future if you need to upgrade certbot to the latest version use this command:

```shell
sudo /opt/certbot/bin/pip install --upgrade certbot certbot-nginx
```

## test Node.js

Create a sample file in `/usr/share/nginx/html/test`, using the following command:

```shell
sudo vi /usr/share/nginx/html/test/server.mjs
```

And then add the following content:

```javascript
import { createServer } from 'node:http';
const server = createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/plain' });
    res.end('Hello World!\n');
});
// starts a simple http server locally on port 3000
server.listen(3000, '127.0.0.1', () => {
    console.log('Listening on 127.0.0.1:3000');
});
```

Now go into the folder in which we created the file:

```shell
cd /usr/share/nginx/html/test
```

And then to start Node.js use this command:

```shell
node server.mjs
```

You will see a message that says **Listening on 127.0.0.1:3000**

Now visit your domain using your browser and you should see a page with the **Hello World!** message

TODO: deploy your code using github actions
TODO: launch an monitor your server using [pm2](https://pm2.keymetrics.io/docs/usage/quick-start/)

</article>
