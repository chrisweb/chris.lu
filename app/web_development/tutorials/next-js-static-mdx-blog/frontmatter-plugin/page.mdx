%toc%

<article>

### frontmatter introduction

As stated in the ["GitHub docs" frontmatter documentation](https://docs.github.com/en/contributing/writing-for-github-docs/using-yaml-frontmatter), the [Jekyll](https://jekyllrb.com/docs/front-matter/) static site generator was the first to popularize frontmatter, but today a lot of frameworks and libraries add support for frontmatter, so maybe your markdown files already have frontmatter and you want to be able to use that data, or as I did when I started with this toturial, you just learned about frontmatter now and think it is a good way to store metdata in your MDX files

You might have noticed that frontmatter is sometimes called "yaml frontmatter" or "frontmatter yaml", this is because frontmatter uses the [YAML data language](https://yaml.org/spec/1.2.2/)

To add frontmatter to a document you start by adding 3 dashes (`---`), then add your frontmatter yaml and finally close the frontmatter block with another 3 dashes (`---`)

I already mentioned the GitHub and Jekyll documentation about frontmatter, they both specify predefined frontmatter variables, but because we will add our own frontmatter support we are actually free to use what ever variables we think are useful for our project, there is however one convention that you should follow and that is to always put the frontmatter part on top of your MDX page or markdown document

> [!MORE]  
> ["YAML data language" specification](https://yaml.org/spec/1.2.2/)  

#### Meta data extraction from frontmatter

What we will do in this chapter is add two plugins to our next/mdx setup, that will read the frontmatter part of our MDX pages and then automatically populate the Next.js metadata object (using the frontmatter metadata) for us

First we install install the 2 remark plugins using the following command:

```shell
npm i remark-frontmatter remark-mdx-frontmatter --save-exact
```

[remark-frontmatter](https://github.com/remarkjs/remark-frontmatter) is a plugin will parse the frontmatter, without this plugin a MDX page with frontmatter would just display the frontmatter as text (when getting rendered), after enabling this plugin the frontmatter part will not show up in your MDX pages anymore but will get parsed as frontmatter yaml

[remark-mdx-frontmatter](https://github.com/remcohaszing/remark-mdx-frontmatter) is a plugin that is important as it will put the parsed frontmatter values into a variable inside of our MDX documents, the variable is called frontmatter by default but you can change the name using the options of the plugin

Next we add the frontmatter plugins to our next/mdx configuration:

```js title="next.config.mjs" showLineNumbers {10-11} /remarkFrontmatter, remarkMdxFrontmatter/#special
import { withSentryConfig } from '@sentry/nextjs'
import createMdx from '@next/mdx'
import rehypeMDXImportMedia from 'rehype-mdx-import-media'
import rehypePrettyCode from 'rehype-pretty-code'
import { readFileSync } from 'fs'
import rehypeSlug from 'rehype-slug'
import { remarkTableOfContents } from 'remark-table-of-contents'
import remarkGfm from 'remark-gfm'
import { rehypeGithubAlerts } from 'rehype-github-alerts'
import remarkFrontmatter from 'remark-frontmatter'
import remarkMdxFrontmatter from 'remark-mdx-frontmatter'

const nextConfig = (phase) => {

    const themePath = new URL('./node_modules/material-theme/themes/OneDark-Pro.json', import.meta.url)
    const themeFileContent = readFileSync(themePath, 'utf-8')

    /** @type {import('rehype-pretty-code').Options} */
    const rehypePrettyCodeOptions = {
        theme: JSON.parse(themeFileContent),
        keepBackground: false,
        defaultLang: {
            block: 'tsx',
            inline: 'js',
        },
        tokensMap: {
            fn: 'entity.name.function',
            cmt: 'comment',
            str: 'string',
            var: 'entity.name.variable',
            obj: 'variable.other.object',
            prop: 'meta.property.object',
            int: 'constant.numeric',
        },
    }

    /** @type {import('remark-table-of-contents').IRemarkTableOfContentsOptions} */
    const remarkTableOfContentsOptions = {
        containerAttributes: {
            id: 'articleToc',
        },
        navAttributes: {
            'aria-label': 'table of contents'
        },
        maxDepth: 3,
    }

    /** @type {import('remark-gfm').Options} */
    const remarkGfmOptions = {
        singleTilde: false,
    }

    const withMDX = createMdx({
        extension: /\.(md|mdx)$/,
        options: {
            // optional remark and rehype plugins
            remarkPlugins: [remarkFrontmatter, remarkMdxFrontmatter, [remarkTableOfContents, remarkTableOfContentsOptions], [remarkGfm, remarkGfmOptions]],
            rehypePlugins: [rehypeGithubAlerts, rehypeSlug, rehypeMDXImportMedia, [rehypePrettyCode, rehypePrettyCodeOptions]],
            remarkRehypeOptions: {
                footnoteLabel: 'Notes',
                footnoteLabelTagName: 'span',
            },
        },
    })
```

Line 10 to 11 we import the 2 frontmatter plugins

Line 57 we add both to our remark plugins list

> [!NOTE]  
> Something I will not cover here, but if you want to go a step further and are interested in adding linting for the frontmatter part, then have a look at [remark-lint-frontmatter-schema](https://github.com/JulianCataldo/remark-lint-frontmatter-schema)  

> [!MORE]  
> [mdx.js "Frontmatter" documentation](https://mdxjs.com/guides/frontmatter/)  
> [Next.js "Frontmatter" documentation](https://nextjs.org/docs/app/building-your-application/configuring/mdx#frontmatter)  
> [npmjs.com "remark-frontmatter" page](https://www.npmjs.com/package/remark-frontmatter)  
> [npmjs.com "remark-mdx-frontmatter" page](https://www.npmjs.com/package/remark-mdx-frontmatter)  

Now it time to create an example where we define some frontmatter, let both plugins do their magic and then use the frontmatter variable to populate the Next.js metadata object

Lets reuse our gfm_plaground page one more time, first remove the current metadata and then add this instead:

```md title="/app/tutorial_examples/gfm_playground/page.mdx" showLineNumbers
---
title: GFM playground page
keywords: ['gfm', 'playground', 'frontmatter', 'mdx']
published: 2024-05-24T19:14:23.792Z
modified: 2024-05-24T19:14:23.792Z
permalink: http://localhost:3000/tutorial_examples/gfm_playground
siteName: My website name
---

export const metadata = {
    title: frontmatter.title,
    keywords: frontmatter.keywords,
    openGraph: {
        url: frontmatter.permalink,
        siteName: frontmatter.siteName,
        type: 'article',
        publishedTime: frontmatter.published,
        modifiedTime: frontmatter.modified,
    }
}

<div id="core">

<article>

# {frontmatter.title.toUpperCase()}

~~strikethrough~~

Table:
| Left    | Right   |
| -------- | ------- |
| Foo       | Bar |
| ~~strikethrough~~ | ðŸ˜ƒ |
| `code` | [external link](https://google.com) |

Autolink: https://www.example.com

Tasklist:
* [x] foo  
* [ ] bar  

Example text with a note.[^1]  
[^1]: This is the text of the note, [it can be a link too](https://www.example.com)  

> [!NOTE]  
> Highlights information that users should take into account, even when skimming.

> [!TIP]  
> Optional information to help a user be more successful.

> [!IMPORTANT]  
> Crucial information necessary for users to succeed.

> [!WARNING]  
> Critical content demanding immediate user attention due to potential risks.

> [!CAUTION]  
> Negative potential consequences of an action.

</article>

</div>

```

Line 1 to 8 we first added our frontmatter on top of the page with some variables we will use in the MDX page itself

Line 10 to 20 we created a Next.js metadata object and used the frontmatter variable (that holds all they key / values from our frontmatter above) to populate it

Line 26 we added a heading and used the frontmatter title value to demonstrate that the frontmatter variable can be used for more than just metadata

Finally make sure the dev server is running, then open the playground page [http://localhost:3000/tutorial_examples/gfm_playground](http://localhost:3000/tutorial_examples/gfm_playground) in your browser and then right click in the page to have a look at the meta tags of the `<head>` element

You should be getting the following result:

```html showLineNumbers
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<title>GFM playground page | example.com</title>
<meta name="description" content="My description">
<meta name="keywords" content="gfm,playground,frontmatter,mdx">
<meta property="og:title" content="GFM playground page | example.com">
<meta property="og:description" content="My description">
<meta property="og:url" content="http://localhost:3000/tutorial_examples/gfm_playground">
<meta property="og:site_name" content="My website name">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2024-05-24T19:14:23.792Z">
<meta property="article:modified_time" content="2024-05-24T19:14:23.792Z">
```

Line 1 to 2 are the viewport and charset Next.js adds by default

Line 3 is the default [HTML title element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/title) that has the frontmatter.title as value and uses the template we have set in the layout file

Line 4 is similar but holds the **description**

Line 5 we have a **keywords** meta tag, which contains some keywords we added to our frontmatter, it is an example of how an array gets transformed into a string, but search engines like [google apparently don't use it](https://developers.google.com/search/docs/crawling-indexing/special-tags)

Line 6 and 7 we have **open graph title and description** which Next.js sets based on the default title and description

Line 8 and 9 we have the **open graph url and sitename** which are two values we have set in our frontmatter (and they overwrite the opengraph values set in the layout)

Line 10 I added a static value as **open graph type** just to demoinstrate the following two meta tags

Line 11 and 12 we have two new meta tags, which have a property that is not prefixed with `og:` but as can be seen on [https://ogp.me/#type_article](https://ogp.me/#type_article) they are part of the open graph protocol, the open graph **article namespace** needs to have the **open graph type** set to **article** and then you get tags that are **prefixed** with `article:`, if however the type is for example set to website those two metatags will not show up

Congratulations you just learned how to set metadata for MDX pages and how to add frontmatter to MDX documents ðŸŽ‰

</article>
